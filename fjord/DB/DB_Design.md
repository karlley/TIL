# DB設計の手順

1. ブロック分け
2. ブロック毎にイベント系エンティティを洗い出す
3. イベント系エンティティの正規化、リソース系エンティティの洗い出し
4. リソース系エンティティを分類化、正規化
5. ブロック間でリソースの統合、正規化
6. 導出系の整理、最終的な正規化

## 1. ブロック分け

部門、業務、ジャンル等で分ける

## 2. ブロック毎にイベント系エンティティを洗い出す

* 動詞で言えるエンティティがイベント系
* タイムスタンプが打てるエンティティがイベント系
* Whenが設定できるエンティティがイベント系
* リソース系に比べて数が少ない
* 「~する予定」と言えるエンティティはイベント系 
* 大きなエンティティを書き出すことに注力

## 3. イベント系エンティティの正規化、リソース系エンティティの洗い出し

* 「誰が・何が」に当たる部分がリソース系エンティティ
* イベント系を正規化することでリソース系が浮かび上がる

## 4. リソース系エンティティを分類化、正規化

* サブセット(副集合)でエンティティを区分する
* 大量のエンティティを分類していくイメージ
* 変更に柔軟に対応できるように交差エンティティをできるだけ使っておく
* この時点で性能は考えない

## 5. ブロック間でリソースの統合、正規化

* 複数のブロックで重複しているリソース系エンティティを統合する
* イベント系エンティティは自然とブロックで独立しているので統合作業は不要
* 関連エンティティには交差エンティティを使う
* DB設計で一番重要な部分

## 6. 導出系の整理、最終的な正規化

以下を排除する

* 導出エンティティ: 元データから計算などによって導き出されるエンティティ
* 重複エンティティ: 他のデータからコピーして作られるエンティティ

正規化のポイント

* 管理するべきエンティティが欠落しないか
* 時間の経過で変化する可能性はないか
* 導出エンティティの算出方法が複雑でないか
* 画面、帳票上に表示される場合は削除しない
* 導出エンティティでも分かり易さを重視する場合は削除しない
* 導出エンティティの算出方法が複雑な場合は削除しない
* 時間の経過で変化しそうなエンティティは詳細テーブルを用意してマスタから参照する
* 性能を気にして導出エンティティをたくさん作らない

# 交差エンティティ

[30分でわかるER図の書き方 \(10\) \- とあるソフトウェア開発者のブログ](https://simply-k.hatenadiary.org/entry/20100716/1279234458)

* 多対多のリレーションシップをもつエンティティの間に設けるエンティティ
* 関連エンティティ、中間テーブル、関連テーブル などと呼ばれる

# 交差エンティティの命名の注意点

[交差テーブルには関連の意味を表す名前をつけよう \- Qiita](https://qiita.com/tkawa/items/dc3e313021f32fd91ca6)

* リレーションのある2つのテーブル名を繋げた命名は関連がイメージできないのでNG
* リレーションのあるテーブルの関連性を表す動詞の名詞形で表現するのが良い

# view 

[ビューとは？使い方を解説](https://products.sint.co.jp/siob/blog/view)

[関係データベースにおけるview（ビュー）について。テーブルとの違いやviewを使うメリット \| 株式会社LIG](https://liginc.co.jp/548364)

* 仮想テーブル
* SQLの集合に名前を付けて保存したもの
* 重複したSQLを書かずに済む
* `CREATE TABLE` で作成される物理的なテーブルとは異なる
* 特殊な場合を除いてデータの更新、削除も可能


# 用語

* ヘッダ・ディテール/マスタ・ディテール: 見出し明細、テーブルをまとめと詳細の2つに分けること
* サブルーチン: 関数、連接・分岐・繰り返しなどの処理をひとまとめにして名前を付けたもの
* ストアドプロシージャ: SQLの集合をあらかじめ保存しておき、関数のように呼び出すように実行できるもの
* ストアドファンクション(stored function): SQLの集合をあらかじめ保存しておき、関数のように呼び出すように実行できるもの、ストアド・プロシージャと異なり実行結果を何らかの値として返却可能
* データモデリング: 模擬的に図式化すること
* タプル(tuple): データ項目の組み合わせの構造、テーブルに中に入っているレコード
* インスタンス: タプルに実際の値が入って実現化したもの
* ドメイン: データ項目、テーブルのカラム(列)
* サブセット: 副集合、ある集合から特定の要素を取り出して部分集合を形成すること

# 概念モデル、論理モデル、物理モデル

[ER図 論理・物理を使い分ける例](https://products.sint.co.jp/ober/blog/logic-physics)

* 概念モデル: システム全体をモデル化し事象ごとに大まかな分類をしたもの、現実の世界から抽出したもの
* 論理モデル: 概念モデルを基に詳細に落とし込んだもの、ER図
* 物理モデル: 論理モデルを基にさらに詳細に落とし込んだもの、実際のDB

# 自己参照とは

[【DB設計】自己参照する多対多の関係を分かりやすく説明する \- Qiita](https://qiita.com/lamp7800/items/81ce4ea3bb0e1f8d6972)

[やさしい図解で学ぶ　中間テーブル　多対多　概念編 \- Qiita](https://qiita.com/ramuneru/items/db43589551dd0c00fef9)

[自己参照関係ってどんな関係？ \- Xupper技術サポート部のページ](https://blog.goo.ne.jp/tecsup/e/fc2958a69546895a76bc8bdf8b5fcf6b)

[楽々ERDレッスン第三回 \| FJORD BOOT CAMP（フィヨルドブートキャンプ）](https://bootcamp.fjord.jp/questions/900)

> 自己参照とは、参照するエンティティが自分自身である場合をいいます。

* ある1つのIDに対して2つ以上の区分を持たせたい場合に参照先が参照元のカラム自身である
* 参照先が同一テーブルでもテーブル名を別名にすることで結合できる(自己結合)
* 自己参照テーブルのレコードにはあるエンティティに属するエンティティのID(自分自身のカラムのID)が保存される

# 動画で得たDB設計の知見

[Q&A掲示板のER図を書くとしたら？ \| FJORD BOOT CAMP（フィヨルドブートキャンプ）](https://bootcamp.fjord.jp/questions/878)

* エンティティを抽出したら必要最低限のカラムを書き出した方がイメージが湧く
* フラグ用のカラムを持たせることで別テーブルが不要になる
* 別テーブルに切り出す要素が1:1の場合はカラム(属性)の方が良い
* リレーションを示す線は`1:1`か`1:多`が判別しやすく書く(多のカーディナリティのみ書く)
* 多:多は中間テーブルを使う
* 別テーブルに切り出す場合は切り出すテーブルのカラム数が少ない場合は属性で持たせることができないか先に検討する
* 別テーブルに切り出すことで`null` を避けることができる
* `null` を無くすことだけが正しい設計ではないかも
* `null` を無くすことに注力しすぎるとテーブル数が増える弊害が出る
* テーブルは必要になったら分ける感じで良いかも
* 区分の種類が少ない場合は別テーブルに切り出さない
* 区分によって動きを変える場合は別テーブルに切り出さずにハードコードした方が良い
* ER図は手書きでも良い
* リレーションを繋いでいる同士のテーブルのどちら側から見ても違和感の無いように設計する
* アプリケーション側で制御する必要性をできるだけ排除するようにする
* 区分を表現したい場合はカラムで属性を追加した方がシンプルな設計になる
