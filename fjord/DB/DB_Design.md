# DB設計の手順

1. ブロック分け
2. ブロック毎にイベント系エンティティを洗い出す
3. イベント系エンティティの正規化、リソース系エンティティの洗い出し
4. リソース系エンティティを分類化、正規化
5. ブロック間でリソースの統合、正規化
6. 導出系の整理、最終的な正規化

## 1. ブロック分け

部門、業務、ジャンル等で分ける

## 2. ブロック毎にイベント系エンティティを洗い出す

* 動詞で言えるエンティティがイベント系
* タイムスタンプが打てるエンティティがイベント系
* Whenが設定できるエンティティがイベント系
* リソース系に比べて数が少ない
* 「~する予定」と言えるエンティティはイベント系 
* 大きなエンティティを書き出すことに注力

## 3. イベント系エンティティの正規化、リソース系エンティティの洗い出し

* 「誰が・何が」に当たる部分がリソース系エンティティ
* イベント系を正規化することでリソース系が浮かび上がる

## 4. リソース系エンティティを分類化、正規化

* サブセット(副集合)でエンティティを区分する
* 大量のエンティティを分類していくイメージ
* 変更に柔軟に対応できるように交差エンティティをできるだけ使っておく
* この時点で性能は考えない

## 5. ブロック間でリソースの統合、正規化

* 複数のブロックで重複しているリソース系エンティティを統合する
* イベント系エンティティは自然とブロックで独立しているので統合作業は不要
* 関連エンティティには交差エンティティを使う
* DB設計で一番重要な部分

## 6. 導出系の整理、最終的な正規化

以下を排除する

* 導出エンティティ: 元データから計算などによって導き出されるエンティティ
* 重複エンティティ: 他のデータからコピーして作られるエンティティ

正規化のポイント

* 管理するべきエンティティが欠落しないか
* 時間の経過で変化する可能性はないか
* 導出エンティティの算出方法が複雑でないか
* 画面、帳票上に表示される場合は削除しない
* 導出エンティティでも分かり易さを重視する場合は削除しない
* 導出エンティティの算出方法が複雑な場合は削除しない
* 時間の経過で変化しそうなエンティティは詳細テーブルを用意してマスタから参照する
* 性能を気にして導出エンティティをたくさん作らない

# 交差エンティティ

[30分でわかるER図の書き方 \(10\) \- とあるソフトウェア開発者のブログ](https://simply-k.hatenadiary.org/entry/20100716/1279234458)

* 多対多のリレーションシップをもつエンティティの間に設けるエンティティ
* 関連エンティティ、中間テーブル、関連テーブル などと呼ばれる

# 交差エンティティの命名の注意点

[交差テーブルには関連の意味を表す名前をつけよう \- Qiita](https://qiita.com/tkawa/items/dc3e313021f32fd91ca6)

* リレーションのある2つのテーブル名を繋げた命名は関連がイメージできないのでNG
* リレーションのあるテーブルの関連性を表す動詞の名詞形で表現するのが良い

# view 

[ビューとは？使い方を解説](https://products.sint.co.jp/siob/blog/view)

[関係データベースにおけるview（ビュー）について。テーブルとの違いやviewを使うメリット \| 株式会社LIG](https://liginc.co.jp/548364)

* 仮想テーブル
* SQLの集合に名前を付けて保存したもの
* 重複したSQLを書かずに済む
* `CREATE TABLE` で作成される物理的なテーブルとは異なる
* 特殊な場合を除いてデータの更新、削除も可能


# 用語

* ヘッダ・ディテール/マスタ・ディテール: 見出し明細、テーブルをまとめと詳細の2つに分けること
* サブルーチン: 関数、連接・分岐・繰り返しなどの処理をひとまとめにして名前を付けたもの
* ストアドプロシージャ: SQLの集合をあらかじめ保存しておき、関数のように呼び出すように実行できるもの
* ストアドファンクション(stored function): SQLの集合をあらかじめ保存しておき、関数のように呼び出すように実行できるもの、ストアド・プロシージャと異なり実行結果を何らかの値として返却可能
* データモデリング: 模擬的に図式化すること
* タプル(tuple): データ項目の組み合わせの構造、テーブルに中に入っているレコード
* インスタンス: タプルに実際の値が入って実現化したもの
* ドメイン: データ項目、テーブルのカラム(列)
* サブセット: 副集合、ある集合から特定の要素を取り出して部分集合を形成すること

# 概念モデル、論理モデル、物理モデル

[ER図 論理・物理を使い分ける例](https://products.sint.co.jp/ober/blog/logic-physics)

* 概念モデル: システム全体をモデル化し事象ごとに大まかな分類をしたもの、現実の世界から抽出したもの
* 論理モデル: 概念モデルを基に詳細に落とし込んだもの、ER図
* 物理モデル: 論理モデルを基にさらに詳細に落とし込んだもの、実際のDB

# 自己参照とは

[【DB設計】自己参照する多対多の関係を分かりやすく説明する \- Qiita](https://qiita.com/lamp7800/items/81ce4ea3bb0e1f8d6972)

[やさしい図解で学ぶ　中間テーブル　多対多　概念編 \- Qiita](https://qiita.com/ramuneru/items/db43589551dd0c00fef9)

[自己参照関係ってどんな関係？ \- Xupper技術サポート部のページ](https://blog.goo.ne.jp/tecsup/e/fc2958a69546895a76bc8bdf8b5fcf6b)

[楽々ERDレッスン第三回 \| FJORD BOOT CAMP（フィヨルドブートキャンプ）](https://bootcamp.fjord.jp/questions/900)

> 自己参照とは、参照するエンティティが自分自身である場合をいいます。

* ある1つのIDに対して2つ以上の区分を持たせたい場合に参照先が参照元のカラム自身である
* 参照先が同一テーブルでもテーブル名を別名にすることで結合できる(自己結合)
* 自己参照テーブルのレコードにはあるエンティティに属するエンティティのID(自分自身のカラムのID)が保存される

# 動画で得たDB設計の知見

[Q&A掲示板のER図を書くとしたら？ \| FJORD BOOT CAMP（フィヨルドブートキャンプ）](https://bootcamp.fjord.jp/questions/878)

* エンティティを抽出したら必要最低限のカラムを書き出した方がイメージが湧く
* フラグ用のカラムを持たせることで別テーブルが不要になる
* 別テーブルに切り出す要素が1:1の場合はカラム(属性)の方が良い
* リレーションを示す線は`1:1`か`1:多`が判別しやすく書く(多のカーディナリティのみ書く)
* 多:多は中間テーブルを使う
* 別テーブルに切り出す場合は切り出すテーブルのカラム数が少ない場合は属性で持たせることができないか先に検討する
* 別テーブルに切り出すことで`null` を避けることができる
* `null` を無くすことだけが正しい設計ではないかも
* `null` を無くすことに注力しすぎるとテーブル数が増える弊害が出る
* テーブルは必要になったら分ける感じで良いかも
* 区分の種類が少ない場合は別テーブルに切り出さない
* 区分によって動きを変える場合は別テーブルに切り出さずにハードコードした方が良い
* ER図は手書きでも良い
* リレーションを繋いでいる同士のテーブルのどちら側から見ても違和感の無いように設計する
* アプリケーション側で制御する必要性をできるだけ排除するようにする
* 区分を表現したい場合はカラムで属性を追加した方がシンプルな設計になる

# ペアプロでの質問/回答

* `user_lists` テーブルのPKを他のテーブルで参照していないが、この形で`user` のリスト一覧は表示できるのか？ 
  * そもそも中間テーブルのPKを他のテーブルから参照することは無い
* 中間テーブルのPK の設定は必要なのか？
  * Rails ではPKは自動で付与されるので手動で追加することはない
* 中間テーブルのレコードから特定のデータのみ(特定の`user`のデータなど)を取得することはできるのか？ 
  * 中間テーブルのPKを参照してデータを取得することはない、親テーブルのPKを元に中間テーブルを利用してデータ取得する
* イベント系のエンティティに必要なカラムを追加する際に`誰が`、`何を` を意識してみたのですがこの考え方は正しいのでしょうか？
  * たぶん正しい
* `users` テーブルから自分のフォロー、フォロワーの一覧が取得できるのか？
  * `friendships` テーブルのレコードをRails がいい感じに処理してくれるのでPKを参照しなくても取得できる
* 他のテーブルから参照していないPK の記述は必要なのでしょうか？
  * Rails が各テーブルのPKは`テーブル名 + _id` で自動生成するので記述を省略する場合が多い
* `tweets`、`replys`、`retweets` テーブルを`tweets` テーブルに属性を追加して1つにまとめようと考えましたがやり方が分かりません
  * 主になるテーブルに自己参照の形でリプライ先の`tweet_id`、リツイート元の`tweet_id` を保存するカラムを追加する
* 設計が正しいか確認する方法はないのか
  * スプレッドシートに実際の値を書き出して不整合が無いか確認する
  * 慣れることが重要、慣れればさほど間違えなくなる
  * 親子の関係を間違えないようにすることに注力する(PK、FKをどちらが持つか)
* PKを使わないことはあるのか
  * 中間テーブルのPKは参照しない
  * Rails はPK はデフォルトで自動生成される
* 親テーブルから中間テーブルの挟んだ先のテーブルの値は参照できるのか
  * 参照できる
  * 中間テーブルはあくまでデータの不整合を防ぐためのテーブル
  * 中間テーブルの情報を直参照することはない
  * 中間テーブルからの親テーブルから中間テーブルのレコードを利用してデータを取得するイメージ
* テーブルに属性を持たせる方法
  * 自己参照の形で主になるテーブルにカラムを追加する
  * 属性のカラムは`NULL` になる場合がある
  * 属性のカラムに`NULL` が入るのを防ぐためには別テーブルを用意するしかない
  * 属性のカラムに`NOT NULL` が指定されているとエラーになる 
* 属性 == フラグ？
  * 一般的には属性とフラグは別もの
  * フラグは通常`true/false` を判断するものを指す
* `user_id` のようなPK名は変更できるのか？
  * 変更可能
  * 理由がなければ通常は変更しない
  * 同一のPKを1つのテーブルのカラムに追加する場合に変更する(`friendships` テーブル)