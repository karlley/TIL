# Railsの基本を理解する

## 開発環境

[Rails6の開発環境の構築 \- karlley's tech blog](https://karlley.hatenablog.jp/entry/2022/06/28/000000)

## バージョン指定してrails new

[バージョン指定してrails new \- karlley's tech blog](https://karlley.hatenablog.jp/entry/2022/06/29/094934)

## rails s でPlease run rails webpacker:install と表示される場合に行うこと

[rails s でPlease run rails webpacker:install と表示される場合に行うこと \- karlley's tech blog](https://karlley.hatenablog.jp/entry/2022/06/29/095327)

## Railsの基本ファイルについて

* Routes、controller、view の順番で処理を行い、HTMLを生成してブラウザへレスポンスを返す
* Routes: リクエストURLとHTTPメソッドに応じてcontrollerとアクションを決める対応表
* controller: 様々sな処理をviewで使う情報をインスタンス変数で渡す
* view: controllerから渡ってきたインスタンス変数をテンプレートに埋め込みHTMLを作る
* routes.rbのパス部の`(.:format)` はレスポンスで返すフォーマットを指定する記述

## webアプリケーション開発時に意識すること

[The Twelve\-Factor App （日本語訳）](https://12factor.net/ja/)

### バージョン管理されている1つのコードベースと複数のデプロイであること

* コードベース:デプロイ は1:多になっている。

### 依存関係を明示的に宣言し分離する

* システムのツールに依存していないことを保証するため。
* 新たに開発に参加した人のセットアップの単純化。

###  設定を環境変数に格納する

* 環境変数はコードを変更することなくデプロイごとに簡単に変更できる
* 認証情報を漏洩させることなく、コードベースを今すぐにでもオープンソースにすることができる。
* 環境変数は言語やOSに依存しない。
* 環境変数はグルーピングできないが、デプロイ毎に独立して管理できるのでスケールアップしやすい。

### バックエンドサービスをアタッチされたリソースとして扱う

* ローカルサービスとサードパーティサービスを区別せずにリソースとして扱う。
* アタッチされたリソースとアタッチする対象のデプロイが疎結合であればコードを変更せずにバックエンドサービスのみを変更できる。

### ビルド、リリース、実行の3つのステージを厳密に分離する

* ビルドステージ: ローカル環境環境で実行可能な塊へと変える変換。
* リリースステージ: ビルドを受け取り、デプロイの設定と結合する。実行環境で実行するための準備。
* 実行: プロセスを起動し、アプリケーションを実行環境で実行する。
* 以前のリリースにロールバックしやすい。
* リリースは常に一意のリリースIDを持つべき。

### アプリケーションを1つもしくは複数のステートレスなプロセスとして実行する

* 永続化する必要のあるすべてのデータはDB等のバックエンドサービスに格納する。
* ユーザーのセッションデータをアプリケーションプロセスのメモリにキャッシュする方法はできれば行わない。

### ポートバインディングを通してサービスを公開する

* Webに公開されるサービスを作成するために、コンテナが実行環境にWebサーバーランタイムを注入することを頼りにしない。
* HTTPをサービスとして公開し、 そのポートにリクエストが来るのを待つ。
* 他のアプリケーションにとってのバックエンドサービスになれる。

### プロセスモデルによってスケールアウトする

* アプリケーションは複数の物理マシンで動作する複数のプロセスへと拡大できなければならない。
* プロセスの並行性を高めるためにOSのプロセスマネージャーを利用し、出力ストリームを管理し、プロセスのクラッシュに対応し、ユーザーによる再起動やシャットダウンを処理すべきである。

### 高速な起動とグレースフルシャットダウンで堅牢性を最大化する

* 素早く柔軟なスケールと、コードや設定に対する変更の素早いデプロイを容易にし、本番デプロイの堅牢性を高める。
* グレースフルシャットダウンは、サービスポートのリッスンを中止し（従って新しいリクエストを拒み）、処理中のリクエストが終了するまで待ち、シャットダウンすることで実現される。
* キューイングバックエンドを使い、クライアントの接続が切断されたり、タイムアウトしたときにジョブをキューに戻せるようにすることでハードウェア障害に対応する。

### 開発、ステージング、本番環境をできるだけ一致させた状態を保つ

* バックエンドサービスの違いは、わずかな非互換性が顕在化し、開発環境やステージング環境では正常に動作してテストも通過するコードが本番環境でエラーを起こす事態を招く原因になる。
* コードを書いた開発者はそのコードのデプロイに深く関わり、そのコードの本番環境での挙動をモニタリングする。
* アプリケーションのすべてのデプロイ（開発、ステージング、本番環境）は同じ種類かつ同じバージョンのバックエンドサービスを利用するべきである。

### ログをイベントストリームとして扱う

* アプリケーションはログファイルに書き込んだり管理しようとするべきではない。代わりに、実行中のプロセスはイベントストリームをstdout（標準出力）に書きだす。
* 開発者はこのストリームをターミナルのフォアグラウンドで見ることで、アプリケーションの挙動を観察する。

### 管理タスクを1回限りのプロセスとして実行する

* マイグレーション等の1回限りの管理プロセスは、アプリケーションの通常の長時間実行されるプロセスと全く同じ環境で実行されるべきである。
* 管理用のコードは、同期の問題を避けるためにアプリケーションコードと一緒にデプロイされるべきである。





