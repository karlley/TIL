## 複数のオプションを追加する

* `optparse` を使う
* 返り値のハッシュのkey は文字列
* key をハッシュにすることも可能だが少し複雑になる
* key はハッシュなのでオプションの指定順は関係しない
* オプションに引数を与える場合は`ARGV.getopts('a:')`のように`:`を付ける

```
require 'optparse'

options = ARGV.getopts('arl')
#=> {"a"=>false, "r"=>false, "l"=>false}
options['a']
#=> false
```

## 動作確認用のファイル、ディレクトリをコミットに含めるのか？

* テストコードを動作させる為に必要なファイルであればコミットする場合もある
* 基本的にはコミットに含めない
* レビューはテストでは無いので動作の全パターンの動作確認をする訳ではない
* レビュワー自身で動作確認用のファイルやディレクトリを作成して動作の確認を行う場合が殆ど

## 三項演算子の可読性を上げる方法

* 長い記述をローカル変数化する
* 三項演算子の中に三項演算子という形は避ける
* if文を使った記述に変更する

## 早期リターン(アーリーリターン)

> あまり起きないケース、あるいは重要でないケースでifのネストを深くしたり、else句を使うのを避けるためのテクニック

* ガード節と同意義
* 不必要な分岐処理を減らすことで可読性が上がる

[rubyで早期return \- Qiita](https://qiita.com/n_slender/items/e062454114facd00a942)

[Rubyのelsifとガード節どちらを使うか \- Qiita](https://qiita.com/mom0tomo/items/779b6e380dc01d3bda54)

## ガード節を使う際の注意点

* `if ~ else` は条件が対比している場合に使うと可読性が上がる
* `next`、`break`、`redo`、`unless` の選択を目的の動作によって使い分ける
* `if` の処理をガード節に置き換える場合は`if` もしくは`==` で肯定型で記述
* `else` の処理をガード節に置き換える場合は`unless` もしくは`!=` で否定型が記述

### next

* ループ中に処理をスキップして次のループを行う
* `next if 条件` のように1行でもok

### break

* ループ中に処理を中断してループを抜ける
* 抜けるループは一番内側のループのみ
* `break if 条件` のように1行でもok

### redo

* ループ中に処理を中断してループをやり直す
* あまり使われない

### unless

* 条件式が偽の時に処理を実行する
* if の反対

## キーワード引数にデフォルト値を設定することで可読性を上げる

メソッドに渡す引数をキーワード引数でデフォルト値を渡すことでメソッドの動きをイメージしやすくする

```
# キーワード引数にデフォルト値を指定
def select_files(all: false, reverse: false)
end

# キーワード引数を使ってメソッド呼び出し
select_files(all: options['a'], reverse: options['r'])
```